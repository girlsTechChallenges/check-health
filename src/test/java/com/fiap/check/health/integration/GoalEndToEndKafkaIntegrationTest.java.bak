package com.fiap.check.health.integration;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fiap.check.health.api.model.GoalRequest;
import com.fiap.check.health.api.model.ProgressRequest;
import com.fiap.check.health.dto.event.GoalCreatedEvent;
import com.fiap.check.health.dto.event.GoalProgressUpdatedEvent;
import com.fiap.check.health.util.TestDataFactory;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.listener.ContainerProperties;
import org.springframework.kafka.listener.KafkaMessageListenerContainer;
import org.springframework.kafka.listener.MessageListener;
import org.springframework.kafka.test.EmbeddedKafkaBroker;
import org.springframework.kafka.test.context.EmbeddedKafka;
import org.springframework.kafka.test.utils.ContainerTestUtils;
import org.springframework.kafka.test.utils.KafkaTestUtils;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.ResultActions;
import org.springframework.transaction.annotation.Transactional;

import java.util.Map;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Testes de Integração End-to-End com Eventos Kafka
 * 
 * Valida a integração completa do fluxo:
 * API → Controller → Service → Repository → Event Publisher → Kafka
 * 
 * Cenários testados:
 * - Criação de meta deve publicar evento GoalCreated
 * - Atualização de progresso deve publicar evento ProgressUpdated
 * - Conclusão de meta deve publicar evento GoalCompleted
 * - Falhas não devem publicar eventos (rollback)
 * - Validação da estrutura e conteúdo dos eventos
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
@EmbeddedKafka(partitions = 1, topics = {"goal.created", "goal.progress.updated", "goal.completed"})
@ActiveProfiles("test")
@DirtiesContext
@DisplayName("End-to-End Integration Tests with Kafka Events")
@Transactional
class GoalEndToEndKafkaIntegrationTest {

    private static final String TOPIC_GOAL_CREATED = "goal.created";
    private static final String TOPIC_PROGRESS_UPDATED = "goal.progress.updated";
    private static final String TOPIC_GOAL_COMPLETED = "goal.completed";

    @Autowired
    private MockMvc mockMvc;

    @Autowired
    private ObjectMapper objectMapper;

    @Autowired
    private EmbeddedKafkaBroker embeddedKafkaBroker;

    private KafkaMessageListenerContainer<String, String> goalCreatedContainer;
    private KafkaMessageListenerContainer<String, String> progressUpdatedContainer;
    private KafkaMessageListenerContainer<String, String> goalCompletedContainer;

    private BlockingQueue<ConsumerRecord<String, String>> goalCreatedRecords;
    private BlockingQueue<ConsumerRecord<String, String>> progressUpdatedRecords;
    private BlockingQueue<ConsumerRecord<String, String>> goalCompletedRecords;

    @BeforeEach
    void setUp() {
        setupKafkaConsumers();
    }

    @Nested
    @DisplayName("Fluxo Completo de Criação de Meta")
    class FluxoCreacaoDeMeta {

        @Test
        @DisplayName("Deve criar meta e publicar evento GoalCreated com sucesso")
        void deveCreiarMetaEPublicarEventoGoalCreatedComSucesso() throws Exception {
            // Given - Request de criação de meta válida
            GoalRequest goalRequest = TestDataFactory.GoalRequestBuilder.createValidGoalRequest();

            // When - Criar meta via API
            ResultActions result = mockMvc.perform(post("/goals")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(goalRequest)))
                    .andExpect(status().isCreated())
                    .andExpect(jsonPath("$.goal_id", notNullValue()));

            // Then - Extrair ID da meta criada
            String responseJson = result.andReturn().getResponse().getContentAsString();
            com.fasterxml.jackson.databind.JsonNode jsonNode = objectMapper.readTree(responseJson);
            String goalId = jsonNode.get("goal_id").asText();

            // Then - Verificar que evento foi publicado
            ConsumerRecord<String, String> record = goalCreatedRecords.poll(10, TimeUnit.SECONDS);
            assertThat(record).isNotNull();
            assertThat(record.topic()).isEqualTo(TOPIC_GOAL_CREATED);

            // Then - Validar conteúdo do evento
            GoalCreatedEvent event = objectMapper.readValue(record.value(), GoalCreatedEvent.class);
            assertThat(event.getGoalId()).isEqualTo(goalId);
            assertThat(event.getUserId()).isEqualTo(goalRequest.getUserId());
            assertThat(event.getTitle()).isEqualTo(goalRequest.getTitle());
            assertThat(event.getDescription()).isEqualTo(goalRequest.getDescription());
            assertThat(event.getCreatedAt()).isNotNull();
        }

        @Test
        @DisplayName("Falha na criação não deve publicar evento")
        void falhaNaCriacaoNaoDevePublicarEvento() throws Exception {
            // Given - Request inválido que causará falha
            GoalRequest invalidRequest = GoalRequest.builder()
                    .userId(null) // Campo obrigatório nulo
                    .title("")    // Título vazio
                    .build();

            // When - Tentar criar meta com dados inválidos
            mockMvc.perform(post("/goals")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(invalidRequest)))
                    .andExpect(status().isBadRequest());

            // Then - Nenhum evento deve ter sido publicado
            ConsumerRecord<String, String> record = goalCreatedRecords.poll(3, TimeUnit.SECONDS);
            assertThat(record).isNull();
        }
    }

    @Nested
    @DisplayName("Fluxo de Atualização de Progresso")
    class FluxoAtualizacaoProgresso {

        @Test
        @DisplayName("Deve atualizar progresso e publicar evento ProgressUpdated")
        void deveAtualizarProgressoEPublicarEventoProgressUpdated() throws Exception {
            // Given - Meta criada primeiro
            GoalRequest goalRequest = TestDataFactory.GoalRequestBuilder.createValidGoalRequest();
            
            String createResponse = mockMvc.perform(post("/goals")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(goalRequest)))
                    .andExpect(status().isCreated())
                    .andReturn().getResponse().getContentAsString();

            com.fasterxml.jackson.databind.JsonNode jsonNode = objectMapper.readTree(createResponse);
            String goalId = jsonNode.get("goal_id").asText();

            // Given - Consumir evento de criação para limpar fila
            goalCreatedRecords.poll(5, TimeUnit.SECONDS);

            // Given - Request de atualização de progresso
            ProgressRequest progressRequest = ProgressRequest.builder()
                    .increment(5)
                    .unit("days")
                    .build();

            // When - Atualizar progresso via API
            mockMvc.perform(patch("/goals/{goalId}/progress", goalId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(progressRequest)))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.progress.completed", is(5)));

            // Then - Verificar que evento foi publicado
            ConsumerRecord<String, String> record = progressUpdatedRecords.poll(10, TimeUnit.SECONDS);
            assertThat(record).isNotNull();
            assertThat(record.topic()).isEqualTo(TOPIC_PROGRESS_UPDATED);

            // Then - Validar conteúdo do evento
            GoalProgressUpdatedEvent event = objectMapper.readValue(record.value(), GoalProgressUpdatedEvent.class);
            assertThat(event.getGoalId()).isEqualTo(goalId);
            assertThat(event.getUserId()).isEqualTo(goalRequest.getUserId());
            assertThat(event.getNewProgress()).isEqualTo(5);
            assertThat(event.getIncrement()).isEqualTo(5);
            assertThat(event.getUpdatedAt()).isNotNull();
        }

        @Test
        @DisplayName("Deve publicar evento GoalCompleted quando meta é finalizada")
        void devePublicarEventoGoalCompletedQuandoMetaEFinalizada() throws Exception {
            // Given - Meta criada com progresso quase completo (28/30)
            GoalRequest goalRequest = TestDataFactory.GoalRequestBuilder.createValidGoalRequest();
            
            String createResponse = mockMvc.perform(post("/goals")
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(goalRequest)))
                    .andExpect(status().isCreated())
                    .andReturn().getResponse().getContentAsString();

            com.fasterxml.jackson.databind.JsonNode jsonNode = objectMapper.readTree(createResponse);
            String goalId = jsonNode.get("goal_id").asText();

            // Given - Consumir evento de criação para limpar fila
            goalCreatedRecords.poll(5, TimeUnit.SECONDS);

            // Given - Primeiro, atualizar para 28/30
            ProgressRequest firstUpdate = ProgressRequest.builder()
                    .increment(28)
                    .unit("days")
                    .build();

            mockMvc.perform(patch("/goals/{goalId}/progress", goalId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(firstUpdate)))
                    .andExpect(status().isOk());

            // Given - Consumir evento de progresso para limpar fila
            progressUpdatedRecords.poll(5, TimeUnit.SECONDS);

            // Given - Segundo, completar a meta (adicionar 2 para chegar em 30)
            ProgressRequest finalUpdate = ProgressRequest.builder()
                    .increment(2)
                    .unit("days")
                    .build();

            // When - Finalizar meta
            mockMvc.perform(patch("/goals/{goalId}/progress", goalId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(finalUpdate)))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.status", is("completed")))
                    .andExpect(jsonPath("$.progress.completed", is(30)));

            // Then - Deve publicar evento de progresso atualizado
            ConsumerRecord<String, String> progressRecord = progressUpdatedRecords.poll(10, TimeUnit.SECONDS);
            assertThat(progressRecord).isNotNull();

            // Then - Deve publicar evento de meta completada
            ConsumerRecord<String, String> completedRecord = goalCompletedRecords.poll(10, TimeUnit.SECONDS);
            assertThat(completedRecord).isNotNull();
            assertThat(completedRecord.topic()).isEqualTo(TOPIC_GOAL_COMPLETED);

            // Then - Validar conteúdo do evento de completion
            com.fasterxml.jackson.databind.JsonNode completedEvent = objectMapper.readTree(completedRecord.value());
            assertThat(completedEvent.get("goalId").asText()).isEqualTo(goalId);
            assertThat(completedEvent.get("userId").asText()).isEqualTo(goalRequest.getUserId());
            assertThat(completedEvent.get("completedAt")).isNotNull();
        }

        @Test
        @DisplayName("Falha na atualização de progresso não deve publicar evento")
        void falhhNaAtualizacaoDeProgressoNaoDevePublicarEvento() throws Exception {
            // Given - ID de meta inexistente
            String nonExistentId = "99999";
            
            ProgressRequest progressRequest = ProgressRequest.builder()
                    .increment(5)
                    .unit("days")
                    .build();

            // When - Tentar atualizar progresso de meta inexistente
            mockMvc.perform(patch("/goals/{goalId}/progress", nonExistentId)
                    .contentType(MediaType.APPLICATION_JSON)
                    .content(objectMapper.writeValueAsString(progressRequest)))
                    .andExpect(status().isNotFound());

            // Then - Nenhum evento deve ter sido publicado
            ConsumerRecord<String, String> record = progressUpdatedRecords.poll(3, TimeUnit.SECONDS);
            assertThat(record).isNull();
        }
    }

    @Nested
    @DisplayName("Cenários de Consistência Transacional")
    class CenariosConsistenciaTransacional {

        @Test
        @DisplayName("Rollback de transação não deve publicar eventos")
        void rollbackDeTransacaoNaoDevePublicarEventos() throws Exception {
            // Este teste seria implementado simulando uma falha durante
            // o processo de criação que force um rollback da transação

            // Given - Request que causará falha após inserção no banco
            GoalRequest goalRequest = TestDataFactory.GoalRequestBuilder.createValidGoalRequest();
            
            // Aqui simularíamos uma condição que cause rollback
            // Por exemplo, erro na validação pós-inserção ou falha no event publisher

            // Then - Verificar que nenhum evento foi publicado após rollback
            ConsumerRecord<String, String> record = goalCreatedRecords.poll(3, TimeUnit.SECONDS);
            assertThat(record).isNull();
        }
    }

    // Métodos auxiliares para configuração do Kafka

    private void setupKafkaConsumers() {
        goalCreatedRecords = new LinkedBlockingQueue<>();
        progressUpdatedRecords = new LinkedBlockingQueue<>();
        goalCompletedRecords = new LinkedBlockingQueue<>();

        setupConsumerForTopic(TOPIC_GOAL_CREATED, goalCreatedRecords, goalCreatedContainer);
        setupConsumerForTopic(TOPIC_PROGRESS_UPDATED, progressUpdatedRecords, progressUpdatedContainer);
        setupConsumerForTopic(TOPIC_GOAL_COMPLETED, goalCompletedRecords, goalCompletedContainer);
    }

    private void setupConsumerForTopic(String topic, BlockingQueue<ConsumerRecord<String, String>> records,
                                     KafkaMessageListenerContainer<String, String> container) {
        Map<String, Object> consumerProps = KafkaTestUtils.consumerProps("test", "false", embeddedKafkaBroker);
        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        
        DefaultKafkaConsumerFactory<String, String> consumerFactory = 
                new DefaultKafkaConsumerFactory<>(consumerProps, new StringDeserializer(), new StringDeserializer());
        
        ContainerProperties containerProperties = new ContainerProperties(topic);
        container = new KafkaMessageListenerContainer<>(consumerFactory, containerProperties);
        container.setupMessageListener((MessageListener<String, String>) records::add);
        container.start();
        
        ContainerTestUtils.waitForAssignment(container, embeddedKafkaBroker.getPartitionsPerTopic());
    }
}